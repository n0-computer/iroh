use std::{
    collections::{hash_map, HashMap},
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
};

use anyhow::anyhow;
use parking_lot::Mutex;

use crate::{
    export::ExportProgress,
    get::{db::DownloadProgress, progress::TransferState},
    util::progress::{FlumeProgressSender, IdGenerator, ProgressSendError, ProgressSender},
};

use super::DownloadKind;

/// The channel that can be used to subscribe to progress updates.
pub type ProgressSubscriber = FlumeProgressSender<DownloadProgress>;

/// Track the progress of downloads.
///
/// This struct allows to create [`ProgressSender`] structs to be passed to
/// [`crate::get::db::get_to_db`]. Each progress sender can be subscribed to by any number of
/// [`ProgressSubscriber`] channel senders, which will receive each progress update (if they have
/// capacity). Additionally, the [`ProgressTracker`] maintains a [`TransferState`] for each
/// transfer, applying each progress update to update this state. When subscribing to an already
/// running transfer, the subscriber will receive a [`DownloadProgress::InitialState`] message
/// containing the state at the time of the subscription, and then receive all further progress
/// events directly.
#[derive(Debug)]
pub struct ProgressTracker {
    transfers: HashMap<DownloadKind, SharedProgress>,
    id_gen: Arc<AtomicU64>,
}

impl ProgressTracker {
    pub fn new() -> Self {
        Self {
            transfers: Default::default(),
            id_gen: Default::default(),
        }
    }

    pub fn create(
        &mut self,
        kind: DownloadKind,
        subscribers: impl IntoIterator<Item = ProgressSubscriber>,
    ) -> SharedProgressSender {
        let inner = Inner {
            subscribers: subscribers
                .into_iter()
                .map(|s| Subscriber::new(s))
                .collect(),
            state: TransferState::new(kind.hash()),
        };
        let inner = Arc::new(Mutex::new(inner));
        let id_gen = Arc::clone(&self.id_gen);
        let shared = SharedProgress { inner, id_gen };
        self.transfers.insert(kind, shared.clone());
        SharedProgressSender(shared)
    }

    pub async fn subscribe(
        &mut self,
        kind: DownloadKind,
        sender: ProgressSubscriber,
    ) -> anyhow::Result<()> {
        self.transfers
            .get_mut(&kind)
            .ok_or_else(|| anyhow!("state for download {kind:?} not found"))?
            .subscribe(sender)
            .await
    }

    pub fn unsubscribe(&mut self, kind: &DownloadKind, sender: &ProgressSubscriber) {
        if let Some(shared) = self.transfers.get_mut(kind) {
            shared.unsubscribe(sender)
        }
    }

    pub fn remove(&mut self, kind: &DownloadKind) {
        self.transfers.remove(kind);
    }
}

#[derive(Debug)]
struct Subscriber {
    /// The progress sender as passed in by the user
    sender: FlumeProgressSender<DownloadProgress>,
    /// Map ids from the shared progress events to ids generated by `sender`
    id_map: HashMap<u64, u64>,
}

impl Subscriber {
    fn new(sender: FlumeProgressSender<DownloadProgress>) -> Self {
        Self {
            sender,
            id_map: Default::default(),
        }
    }

    /// Transforms a progress event by replacing all progress ids with progress ids generated by
    /// `self.sender`
    fn map(&mut self, mut p: DownloadProgress) -> DownloadProgress {
        match &mut p {
            DownloadProgress::InitialState(state) => {
                let len = state.progress_id_to_blob.len();
                let old_map =
                    std::mem::replace(&mut state.progress_id_to_blob, HashMap::with_capacity(len));
                for (progress_id, blob_id) in old_map.into_iter() {
                    state
                        .progress_id_to_blob
                        .insert(self.map_id(progress_id), blob_id);
                }
            }
            DownloadProgress::Found { id, .. } => {
                *id = self.map_id(*id);
            }
            DownloadProgress::Progress { id, .. } => {
                *id = self.map_id(*id);
            }
            DownloadProgress::Done { id } => {
                *id = self.map_and_remove_id(*id).unwrap_or_default();
            }
            DownloadProgress::Export(progress) => match progress {
                ExportProgress::Found { id, .. } => {
                    *id = self.map_id(*id);
                }
                ExportProgress::Progress { id, .. } => {
                    *id = self.map_id(*id);
                }
                ExportProgress::Done { id } => {
                    *id = self.map_and_remove_id(*id).unwrap_or_default();
                }
                _ => {}
            },
            _ => {}
        }
        p
    }

    fn map_id(&mut self, id: u64) -> u64 {
        match self.id_map.entry(id) {
            hash_map::Entry::Occupied(entry) => *entry.get(),
            hash_map::Entry::Vacant(entry) => {
                let id = self.sender.new_id();
                entry.insert(id);
                id
            }
        }
    }
    fn map_and_remove_id(&mut self, id: u64) -> Option<u64> {
        self.id_map.remove(&id)
    }
}

#[derive(Debug, Clone)]
struct SharedProgress {
    inner: Arc<Mutex<Inner>>,
    id_gen: Arc<AtomicU64>,
}

#[derive(Debug)]
struct Inner {
    subscribers: Vec<Subscriber>,
    state: TransferState,
}

impl SharedProgress {
    fn lock(&self) -> parking_lot::MutexGuard<Inner> {
        self.inner.lock()
    }

    async fn subscribe(&self, sender: ProgressSubscriber) -> anyhow::Result<()> {
        let initial_msg = {
            let mut subscriber = Subscriber::new(sender.clone());
            let mut state = self.inner.lock();
            let initial_msg = DownloadProgress::InitialState(state.state.clone());
            let initial_msg = subscriber.map(initial_msg);
            state.subscribers.push(subscriber);
            drop(state);
            initial_msg
        };
        sender.send(initial_msg).await?;
        Ok(())
    }

    fn unsubscribe(&self, sender: &ProgressSubscriber) {
        self.inner
            .lock()
            .subscribers
            .retain(|s| !s.sender.same_channel(sender));
    }
}

impl Inner {
    fn on_progress(&mut self, progress: DownloadProgress) {
        self.state.on_progress(progress);
    }
}

#[derive(Debug, Clone)]
pub struct SharedProgressSender(SharedProgress);

impl IdGenerator for SharedProgressSender {
    fn new_id(&self) -> u64 {
        self.0.id_gen.fetch_add(1, Ordering::SeqCst)
    }
}

impl ProgressSender for SharedProgressSender {
    type Msg = DownloadProgress;

    async fn send(&self, msg: Self::Msg) -> std::result::Result<(), ProgressSendError> {
        let futs = {
            let mut state = self.0.lock();
            state.on_progress(msg.clone());
            let futs = state
                .subscribers
                .iter_mut()
                .map(|s| {
                    let msg = s.map(msg.clone());
                    s.sender.clone().into_send(msg)
                })
                .collect::<Vec<_>>();
            drop(state);
            futs
        };
        // TODO: remove sender from list on error?
        let _ = futures::future::join_all(futs).await;
        Ok(())
    }

    fn try_send(&self, msg: Self::Msg) -> std::result::Result<(), ProgressSendError> {
        let mut state = self.0.lock();
        state.on_progress(msg.clone());
        for s in state.subscribers.iter() {
            // TODO: remove sender from list on error?
            s.sender.try_send(msg.clone()).ok();
        }
        Ok(())
    }

    fn blocking_send(&self, msg: Self::Msg) -> std::result::Result<(), ProgressSendError> {
        let mut state = self.0.lock();
        state.on_progress(msg.clone());
        for s in state.subscribers.iter() {
            // TODO: remove sender from list on error?
            s.sender.blocking_send(msg.clone()).ok();
        }
        Ok(())
    }
}
